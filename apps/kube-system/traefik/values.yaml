traefik:
  # Default values for Traefik
  image:
    name: traefik
    # defaults to appVersion
    tag: "2.4.8"
    pullPolicy: IfNotPresent

  #
  # Configure the deployment
  #
  deployment:
    enabled: true
    # Can be either Deployment or DaemonSet
    kind: DaemonSet
    # Number of pods of the deployment (only applies when kind == Deployment)
    replicas: 1
    # Additional deployment annotations (e.g. for jaeger-operator sidecar injection)
    annotations: {}
    # Additional deployment labels (e.g. for filtering deployment by custom labels)
    labels: {}
    # Additional pod annotations (e.g. for mesh injection or prometheus scraping)
    podAnnotations:
      prometheus.io/port: "8082"
      prometheus.io/scrape: "true"
    # Additional Pod labels (e.g. for filtering Pod by custom labels)
    podLabels: {}
    # Additional containers (e.g. for metric offloading sidecars)
    additionalContainers: []
    additionalVolumes: []
    initContainers: []
    imagePullSecrets: []

  # Pod disruption budget
  podDisruptionBudget:
    enabled: false

  # Use ingressClass. Ignored if Traefik version < 2.3 / kubernetes < 1.18.x
  ingressClass:
    enabled: false
    isDefaultClass: false
    fallbackApiVersion:

  # Activate Pilot integration
  pilot:
    enabled: false
    token: ""
    dashboard: false

  # Enable experimental features
  experimental:
    plugins:
      enabled: false
    kubernetesGateway:
      enabled: false
      appLabelSelector: "traefik"
      certificates: []

  # Create an IngressRoute for the dashboard
  ingressRoute:
    dashboard:
      enabled: false
      annotations: {}
      labels: {}

  rollingUpdate:
    maxUnavailable: 1
    maxSurge: 1

  #
  # Configure providers
  #
  providers:
    kubernetesCRD:
      enabled: true
      namespaces: []
    kubernetesIngress:
      enabled: true
      namespaces: []
      publishedService:
        enabled: true

  volumes: []

  # Additional volumeMounts to add to the Traefik container
  additionalVolumeMounts: []

  # Logs
  # https://docs.traefik.io/observability/logs/
  logs:
    general:
      level: ERROR
    access:
      enabled: true
      filters: {}
      fields:
        general:
          defaultmode: keep
          names: {}
        headers:
          defaultmode: drop
          names: {}


  globalArguments:
    - "--global.checknewversion"

  additionalArguments:
    - "--providers.kubernetesingress.ingressclass=traefik"
    - "--api.insecure=true"

  # Environment variables to be passed to Traefik's binary
  env:
    - name: TZ
      value: Europe/Berlin

  envFrom: []

  # Configure ports
  ports:
    traefik:
      port: 9000
      expose: false
      exposedPort: 9000
      protocol: TCP
    web:
      port: 8000
      expose: true
      exposedPort: 80
      protocol: TCP
      redirectTo: websecure
    websecure:
      port: 8443
      expose: true
      exposedPort: 443
      protocol: TCP
      tls:
        enabled: true
        options: ""
        certResolver: ""
        domains: []
        # - main: example.com
        #   sans:
        #     - foo.example.com
        #     - bar.example.com

  tlsOptions: {}

  # Options for the main traefik service, where the entrypoints traffic comes
  # from.
  service:
    enabled: true
    type: LoadBalancer
    # Additional annotations (e.g. for cloud provider specific config)
    annotations: {}
    # Additional service labels (e.g. for filtering Service by custom labels)
    labels: {}
    # Additional entries here will be added to the service spec. Cannot contains
    # type, selector or ports entries.
    spec:
      externalTrafficPolicy: Cluster
      loadBalancerIP: "10.0.40.20"
    loadBalancerSourceRanges: []
    externalIPs: []

  ## Create HorizontalPodAutoscaler object.
  ##
  autoscaling:
    enabled: false

  persistence:
    enabled: false

  hostNetwork: false

  # Whether Role Based Access Control objects like roles and rolebindings should be created
  rbac:
    enabled: true
    namespaced: false

  # Enable to create a PodSecurityPolicy and assign it to the Service Account via RoleBinding or ClusterRoleBinding
  podSecurityPolicy:
    enabled: false

  # The service account the pods will use to interact with the Kubernetes API
  serviceAccount:
    name: ""

  # Additional serviceAccount annotations (e.g. for oidc authentication)
  serviceAccountAnnotations: {}

  resources:
    requests:
      cpu: "100m"
      memory: "50Mi"
    limits:
      cpu: "300m"
      memory: "150Mi"
  affinity: {}

  nodeSelector:
    kubernetes.io/os: linux
    node-role.kubernetes.io/worker: 'true'

  tolerations: []

  # Pods can have priority.
  # Priority indicates the importance of a Pod relative to other Pods.
  priorityClassName: "system-cluster-critical"

  # Set the container security context
  # To run the container with ports below 1024 this will need to be adjust to run as root
  securityContext:
    capabilities:
      drop:
        - ALL
    readOnlyRootFilesystem: true
    runAsGroup: 65532
    runAsNonRoot: true
    runAsUser: 65532

  podSecurityContext:
    fsGroup: 65532
