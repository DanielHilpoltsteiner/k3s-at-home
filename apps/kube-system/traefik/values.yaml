traefik:
  # Default values for Traefik
  image:
    name: traefik
    # defaults to appVersion
    tag: "2.4.8"
    pullPolicy: IfNotPresent

  #
  # Configure the deployment
  #
  deployment:
    enabled: true
    # Can be either Deployment or DaemonSet
    kind: DaemonSet
    # Number of pods of the deployment (only applies when kind == Deployment)
    replicas: 1
    # Additional deployment annotations (e.g. for jaeger-operator sidecar injection)
    annotations: {}
    # Additional deployment labels (e.g. for filtering deployment by custom labels)
    labels: {}
    # Additional pod annotations (e.g. for mesh injection or prometheus scraping)
    podAnnotations:
      prometheus.io/port: "8082"
      prometheus.io/scrape: "true"
    # Additional Pod labels (e.g. for filtering Pod by custom labels)
    podLabels: {}
    # Additional containers (e.g. for metric offloading sidecars)
    additionalContainers: []
    additionalVolumes: []
    initContainers: []
    imagePullSecrets: []

  # Pod disruption budget
  podDisruptionBudget:
    enabled: false

  # Use ingressClass. Ignored if Traefik version < 2.3 / kubernetes < 1.18.x
  ingressClass:
    enabled: false
    isDefaultClass: false
    fallbackApiVersion:

  # Activate Pilot integration
  pilot:
    enabled: false
    token: ""
    dashboard: false

  # Enable experimental features
  experimental:
    plugins:
      enabled: false
    kubernetesGateway:
      enabled: false
      appLabelSelector: "traefik"
      certificates: []

  # Create an IngressRoute for the dashboard
  ingressRoute:
    dashboard:
      enabled: false
      annotations: {}
      labels: {}

  rollingUpdate:
    maxUnavailable: 1
    maxSurge: 1

  #
  # Configure providers
  #
  providers:
    kubernetesCRD:
      enabled: true
      namespaces: []
    kubernetesIngress:
      enabled: true
      namespaces: []
      publishedService:
        enabled: true

  volumes: []

  # Additional volumeMounts to add to the Traefik container
  additionalVolumeMounts: []

  # Logs
  # https://docs.traefik.io/observability/logs/
  logs:
    general:
      level: ERROR
    access:
      enabled: false
      filters: {}
      fields:
        general:
          defaultmode: keep
          names: {}
        headers:
          defaultmode: drop
          names: {}


  globalArguments:
    - "--global.checknewversion"

  additionalArguments:
    - "--providers.kubernetesingress.ingressclass=traefik"

  # Environment variables to be passed to Traefik's binary
  env: []

  envFrom: []

  # Configure ports
  ports:
    traefik:
      port: 9000
      expose: false
      exposedPort: 9000
      protocol: TCP
    web:
      port: 8000
      expose: true
      exposedPort: 80
      protocol: TCP
      redirectTo: websecure
    websecure:
      port: 8443
      expose: true
      exposedPort: 443
      protocol: TCP
      tls:
        enabled: true
        options: ""
        certResolver: ""
        domains: []
        # - main: example.com
        #   sans:
        #     - foo.example.com
        #     - bar.example.com

  tlsOptions: {}

  # Options for the main traefik service, where the entrypoints traffic comes
  # from.
  service:
    enabled: true
    type: LoadBalancer
    # Additional annotations (e.g. for cloud provider specific config)
    annotations: {}
    # Additional service labels (e.g. for filtering Service by custom labels)
    labels: {}
    # Additional entries here will be added to the service spec. Cannot contains
    # type, selector or ports entries.
    spec:
      externalTrafficPolicy: Cluster
      loadBalancerIP: "10.0.40.20"
      # clusterIP: "2.3.4.5"
    loadBalancerSourceRanges: []
      # - 192.168.0.1/32
      # - 172.16.0.0/16
    externalIPs: []
      # - 1.2.3.4

  ## Create HorizontalPodAutoscaler object.
  ##
  autoscaling:
    enabled: false
  #   minReplicas: 1
  #   maxReplicas: 10
  #   metrics:
  #   - type: Resource
  #     resource:
  #       name: cpu
  #       targetAverageUtilization: 60
  #   - type: Resource
  #     resource:
  #       name: memory
  #       targetAverageUtilization: 60

  # Enable persistence using Persistent Volume Claims
  # ref: http://kubernetes.io/docs/user-guide/persistent-volumes/
  # After the pvc has been mounted, add the configs into traefik by using the `additionalArguments` list below, eg:
  # additionalArguments:
  # - "--certificatesresolvers.le.acme.storage=/data/acme.json"
  # It will persist TLS certificates.
  persistence:
    enabled: false
    name: data
  #  existingClaim: ""
    accessMode: ReadWriteOnce
    size: 128Mi
    # storageClass: ""
    path: /data
    annotations: {}
    # subPath: "" # only mount a subpath of the Volume into the pod

  # If hostNetwork is true, runs traefik in the host network namespace
  # To prevent unschedulabel pods due to port collisions, if hostNetwork=true
  # and replicas>1, a pod anti-affinity is recommended and will be set if the
  # affinity is left as default.
  hostNetwork: false

  # Whether Role Based Access Control objects like roles and rolebindings should be created
  rbac:
    enabled: true

    # If set to false, installs ClusterRole and ClusterRoleBinding so Traefik can be used across namespaces.
    # If set to true, installs namespace-specific Role and RoleBinding and requires provider configuration be set to that same namespace
    namespaced: false

  # Enable to create a PodSecurityPolicy and assign it to the Service Account via RoleBinding or ClusterRoleBinding
  podSecurityPolicy:
    enabled: false

  # The service account the pods will use to interact with the Kubernetes API
  serviceAccount:
    # If set, an existing service account is used
    # If not set, a service account is created automatically using the fullname template
    name: ""

  # Additional serviceAccount annotations (e.g. for oidc authentication)
  serviceAccountAnnotations: {}

  resources:
    requests:
      cpu: "100m"
      memory: "50Mi"
    limits:
      cpu: "300m"
      memory: "150Mi"
  affinity: {}
  
  nodeSelector:
    kubernetes.io/os: linux
    node-role.kubernetes.io/worker: 'true'

  tolerations: []

  # Pods can have priority.
  # Priority indicates the importance of a Pod relative to other Pods.
  priorityClassName: "system-cluster-critical"

  # Set the container security context
  # To run the container with ports below 1024 this will need to be adjust to run as root
  securityContext:
    capabilities:
      drop: 
        - ALL
    readOnlyRootFilesystem: true
    runAsGroup: 65532
    runAsNonRoot: true
    runAsUser: 65532

  podSecurityContext:
    fsGroup: 65532